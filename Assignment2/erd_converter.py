from erd import *
from table import *

def formatForeignKey(connectionTables,primary_key):
    foreignKeys = []
    for i in range(len(connectionTables)):
        table = connectionTables[i]
        pk = primary_key[i]
        foreignKeys.append(((pk,), table, (pk,)))
    return foreignKeys


def convert_to_db(tableSet, relationshipSet):
    # print(tableSet)
    # print(relationshipSet)

    # [table: Table]
    db = []

    # build a table form entrySet
    for key, value in tableSet.items():
        name = key
        attributes = value[0]
        primary_key = value[1]
        connections = value[2]

        # print(key, attributes, primary_key)

        if not connections:
            db.append(Table(name, set(attributes), set(primary_key), set()))
        else:
            if connections[1] == "MANY":
                db.append(Table(name, set(attributes), set(primary_key), set()))

    # build a table form relationshipSet
    for key, value in relationshipSet.items():
        name = key
        type = value[0]
        connectionTables = value[1]
        attribute = value[2]
        primary_key = value[3]

        db.append(Table(name, set(attribute), set(primary_key), set(formatForeignKey(connectionTables,primary_key))))

    print("\n".join([str(val) for val in db]))

    return Database(db)


# This function converts an ERD object into a Database object
# The Database object should correspond to a fully correct implementation
# of the ERD, including both data structure and constraints, such that the
# CREATE TABLE statements generated by the Database object will populate an
# empty MySQL database to exactly implement the conceptual design communicated
# by the ERD.
#
# @TODO: Implement me!
def convert_to_table( erd ):
    relationshipList = erd.relationships
    entrySetList = erd.entity_sets

    # {tableName: str, [[attribute set], [primary key]]}
    tableSet = {}

    # {relationshipName: str, [type:str, [connection tables], [attribute set], [primary key]]}
    relationshipSet = {}

    # extract relationships
    for relationship in relationshipList:
        name = relationship.name
        attribute = relationship.attributes
        primary_keys = relationship.primary_key

        # create a new set
        if name not in relationshipSet:
            relationshipSet[name] = ["", []]

        if attribute:
            relationshipSet[name].append(attribute)
        else:
            relationshipSet[name].append([])

        if primary_keys:
            relationshipSet[name].append(primary_keys)
        else:
            relationshipSet[name].append([])



    # extract entrySet properties
    for entry in entrySetList:
        name = entry.name
        attribute_list = entry.attributes
        primary_key_list = entry.primary_key

        #[[name: str, type: int]]
        connections = entry.connections

        # create a new set
        if name not in tableSet:
            tableSet[name] = []

        # get attributes
        if attribute_list:
            tableSet[name].append(attribute_list)
        else:
            tableSet[name].append([])

        # get primary key
        if primary_key_list:
            tableSet[name].append(primary_key_list)
        else:
            tableSet[name].append([])

        # get connections
        if connections:
            for connection in connections:
                relation_name = connection[0]
                type = connection[1].name
                tableSet[name].append([relation_name, type])

                # make relationship set
                if relation_name not in relationshipSet:
                    relationshipSet[relation_name] = [type, [], [], []]
                # add more data to relationship set
                relationshipSet[relation_name][0] = type
                relationshipSet[relation_name][1].append(name)
                [relationshipSet[relation_name][2].append(pk) for pk in primary_key_list]
                [relationshipSet[relation_name][3].append(pk) for pk in primary_key_list]

        else:
            tableSet[name].append([])

    # make db
    db = convert_to_db(tableSet, relationshipSet)

    return db
    # return Database([])
    # return sample_db
